# Findings Summary

| ID     | Title                                                             | Severity     |
| ------ | ----------------------------------------------------------------- | ------------ |
| [L-01] | accrueTimeWeightedLiquidity may fail due to running out of gas    | Low          |
| [N-01] | Better to make sure crossTicks don't revert                       | Non-Critical |
| [N-02] | The user can't accrue rewards when week + WEEK == block.timestamp | Non-Critical |

# Detailed Findings

# [L-01] accrueTimeWeightedLiquidity may fail due to running out of gas

## Description

This is very likely to happen, mainly for the `accumulateConcentratedPositionTimeWeightedLiquidity` function.
The time range can be specified when the user claims the reward, but `accumulateConcentratedPositionTimeWeightedLiquidity` will update state from `lastAccrued` to the current time, and is not affected by the parameters passed in by the user.
For a large tick range position that has not been updated for a long time, claiming the reward will consume a lot of gas and may cause the transaction to fail.

## Recommendations

`accumulateConcentratedPositionTimeWeightedLiquidity` should only update the state for the specified time range

# [N-01] Better to make sure crossTicks don't revert

## Description

```solidity
    /// @notice Keeps track of the tick crossings
    /// @dev Needs to be called whenever a tick is crossed
    function crossTicks(
        bytes32 poolIdx,
        int24 exitTick,
        int24 entryTick
    ) internal {
        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;
        tickTracking_[poolIdx][exitTick][numElementsExit - 1]
            .exitTimestamp = uint32(block.timestamp);
        StorageLayout.TickTracking memory tickTrackingData = StorageLayout
            .TickTracking(uint32(block.timestamp), 0);
        tickTracking_[poolIdx][entryTick].push(tickTrackingData);
    }
```

`crossTicks` will be called every time the tick changes. If exitTickTracking is empty, crossTicks revert will DOS swap operation.    
Although exitTickTracking should be generated by calling `initTickTracking` during initialization, it's better to verify that exitTickTracking is not empty in `crossTicks`.

## Recommendations

Check `numElementsExit > 0`

# [N-02] The user can't accrue rewards when week + WEEK == block.timestamp

## Description

```solidity
    for (uint256 i; i < weeksToClaim.length; ++i) {
        uint32 week = weeksToClaim[i];
        // @audit Revert when week + WEEK == block.timestamp
        require(week + WEEK < block.timestamp, "Week not over yet");
        require(
            !concLiquidityRewardsClaimed_[poolIdx][posKey][week],
            "Already claimed"
        );
    }
```

## Recommendations

Use `week + WEEK <= block.timestamp` instead of `week + WEEK < block.timestamp`
