# Findings Summary

| ID     | Title                                                             | Severity     |
| ------ | ----------------------------------------------------------------- | ------------ |
| [L-01] | The accrueTimeWeightedLiquidity may fail due to run out of gas    | Low          |
| [L-02] | A small amount unclaimed reward may be locked forever in contract | Low          |
| [N-01] | Better to make sure crossTicks don't revert                       | Non-Critical |
| [N-02] | The user can't accrue rewards when week + WEEK == block.timestamp | Non-Critical |

# Detailed Findings

# [L-01] The accrueTimeWeightedLiquidity may fail due to run out of gas

## Description

This is very likely to happen, mainly for the `accumulateConcentratedPositionTimeWeightedLiquidity` function.
The time range can be specified when the user claims the reward, but `accumulateConcentratedPositionTimeWeightedLiquidity` will update state from `lastAccrued` to the current time, and is not affected by the parameters passed in by the user.
For a large tick range position that has not been updated for a long time, claiming the reward will consume a lot of gas and may cause the transaction to fail.

## Recommendations

`accumulateConcentratedPositionTimeWeightedLiquidity` should only update the state for the specified time range

# [L-02] A small amount unclaimed reward may be locked forever in contract

## Description

`LiquidityMiningPath` allows the owner to transfer in ETH and set rewards, but it does not provide any method to withdraw unclaimed rewards in the contract, and the upper `CrocSwapDex` proxy contract does not have any support.
Since the rewards are distributed according to the liquidity ratio, if some users never claim the rewards, the remaining rewards will be locked in the contract permanently, causing a loss of funds.

## Recommendations

Add a new method to withdraw funds

# [N-01] Better to make sure crossTicks don't revert

## Description

```solidity
    /// @notice Keeps track of the tick crossings
    /// @dev Needs to be called whenever a tick is crossed
    function crossTicks(
        bytes32 poolIdx,
        int24 exitTick,
        int24 entryTick
    ) internal {
        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;
        tickTracking_[poolIdx][exitTick][numElementsExit - 1]
            .exitTimestamp = uint32(block.timestamp);
        StorageLayout.TickTracking memory tickTrackingData = StorageLayout
            .TickTracking(uint32(block.timestamp), 0);
        tickTracking_[poolIdx][entryTick].push(tickTrackingData);
    }
```

`crossTicks` will be called every time the tick changes. If exitTickTracking is empty, crossTicks revert will DOS swap operation.    
Although exitTickTracking should be generated by calling `initTickTracking` during initialization, it's better to verify that exitTickTracking is not empty in `crossTicks`.

## Recommendations

Check `numElementsExit > 0`

# [N-02] The user can't accrue rewards when week + WEEK == block.timestamp

## Description

```solidity
    for (uint256 i; i < weeksToClaim.length; ++i) {
        uint32 week = weeksToClaim[i];
        // @audit Revert when week + WEEK == block.timestamp
        require(week + WEEK < block.timestamp, "Week not over yet");
        require(
            !concLiquidityRewardsClaimed_[poolIdx][posKey][week],
            "Already claimed"
        );
    }
```

## Recommendations

Use `week + WEEK <= block.timestamp` instead of `week + WEEK < block.timestamp`
